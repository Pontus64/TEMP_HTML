<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>MediaPipe AI ç©ºä¸­æ‰‹åŠ¿ç»˜å›¾æ¿</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1e1e1e;
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }

        /* è§†é¢‘å±‚ï¼ˆéšè—ï¼Œåªç”¨äºAIåˆ†æï¼‰ */ 
        #input_video {
            display: none;
        }

        /* ç»˜å›¾å±‚ */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid #00d2ff;
            border-radius: 20px;
            padding: 20px;
            display: none;
            /* é»˜è®¤éšè— */
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.3);
            z-index: 100;
            pointer-events: none;
            /* è®©JSæ¥ç®¡ç¢°æ’æ£€æµ‹ */
        }

        .ui-item {
            height: 80px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #444;
            transition: all 0.3s;
            position: relative;
        }

        .ui-item.active {
            border-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
            transform: scale(1.05);
        }

        .ui-item.hovered {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* é¢œè‰²å—æ ·å¼ */
        .color-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
        }

        /* åŠ è½½æç¤º */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00d2ff;
        }

        /* æŒ‡é’ˆï¼ˆæ¨¡æ‹Ÿé¼ æ ‡ï¼‰ */
        #cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid white;
            pointer-events: none;
            z-index: 200;
            display: none;
            transform: translate(-50%, -50%);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>

    <div id="loading">æ­£åœ¨åŠ è½½ AI æ¨¡å‹ï¼Œè¯·ç¨å€™...<br>(è¯·å…è®¸æ‘„åƒå¤´æƒé™)</div>

    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>

    <div id="cursor"></div>

    <div id="ui-panel">
        <div class="ui-item" data-type="color" data-val="#ff0000">
            <div class="color-circle" style="background:#ff0000"></div>
        </div>
        <div class="ui-item" data-type="color" data-val="#00ff00">
            <div class="color-circle" style="background:#00ff00"></div>
        </div>
        <div class="ui-item" data-type="color" data-val="#0000ff">
            <div class="color-circle" style="background:#0000ff"></div>
        </div>
        <div class="ui-item" data-type="color" data-val="#ffffff">
            <div class="color-circle" style="background:#ffffff"></div>
        </div>

        <div class="ui-item" data-type="size" data-val="5">ç»†ç¬”</div>
        <div class="ui-item" data-type="size" data-val="15">ä¸­ç¬”</div>
        <div class="ui-item" data-type="size" data-val="30">ç²—ç¬”</div>

        <div class="ui-item" data-type="tool" data-val="pen">âœï¸ ç¬”</div>
        <div class="ui-item" data-type="tool" data-val="eraser">ğŸ§½ æ©¡çš®</div>
    </div>

    <script>
        // --- 1. åˆå§‹åŒ–å˜é‡ ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const uiPanel = document.getElementById('ui-panel');
        const cursor = document.getElementById('cursor');

        let width, height;

        // çŠ¶æ€å˜é‡
        let paths = []; // å­˜å‚¨æ‰€æœ‰ç¬”ç”»: [{points: [{x,y}], color, size, isEraser}]
        let currentPath = [];
        let particles = []; // é›ªèŠ±ç²’å­

        // è®¾ç½®
        let brushColor = '#ffffff';
        let brushSize = 10;
        let tool = 'pen'; // 'pen' or 'eraser'

        // æ‰‹åŠ¿çŠ¶æ€
        let isMenuOpen = false;
        let lastMenuToggleTime = 0; // é˜²æŠ–
        let zoomLevel = 1;
        let zoomOrigin = { x: 0, y: 0 };
        let lastPinchDist = null;

        // UI äº¤äº’
        let hoverTimer = null;
        let lastHoveredItem = null;

        // è°ƒæ•´ç”»å¸ƒå°ºå¯¸
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvasElement.width = width;
            canvasElement.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 2. è¾…åŠ©å‡½æ•° ---
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // ç²’å­ç±» (é›ªèŠ±)
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = Math.random() * 5 + 2;
                this.alpha = 1;
                this.size = Math.random() * 3 + 1;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= 0.01;
                this.vx *= 0.95; // é˜»åŠ›
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // --- 3. æ ¸å¿ƒé€»è¾‘: onResults ---
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            // 1. ç»˜åˆ¶èƒŒæ™¯ (é•œåƒè§†é¢‘)
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);
            canvasCtx.translate(width, 0);
            canvasCtx.scale(-1, 1);
            canvasCtx.drawImage(results.image, 0, 0, width, height);
            canvasCtx.restore();

            // 2. å¤„ç†æ‰‹éƒ¨
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {

                // å¤„ç†åŒæ‰‹ç¼©æ”¾é€»è¾‘
                if (results.multiHandLandmarks.length === 2) {
                    handleZoom(results.multiHandLandmarks);
                } else {
                    lastPinchDist = null; // é‡ç½®ç¼©æ”¾é”
                }

                // å¤„ç†ä¸»è¦æ‰‹åŠ¿ (é€šå¸¸å–ç¬¬ä¸€åªæ‰‹ä½œä¸ºä¸»æ‰‹)
                const landmarks = results.multiHandLandmarks[0];
                handleGestures(landmarks);

                // ç»˜åˆ¶æ‰‹éª¨æ¶ (å¯é€‰ï¼Œè¾…åŠ©è°ƒè¯•)
                // drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
            } else {
                // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œç»“æŸå½“å‰ç¬”ç”»
                if (currentPath.length > 0) {
                    paths.push({ points: currentPath, color: brushColor, size: brushSize, tool: tool });
                    currentPath = [];
                }
            }

            // 3. ç»˜åˆ¶ç¬”è¿¹
            drawPaths();

            // 4. ç»˜åˆ¶ç²’å­
            updateAndDrawParticles();
        }

        // --- 4. æ‰‹åŠ¿é€»è¾‘ ---
        function handleGestures(landmarks) {
            // åæ ‡è½¬æ¢ (å½’ä¸€åŒ– -> åƒç´ ) & é•œåƒå¤„ç†
            // æ³¨æ„ï¼šMediaPipe xåæ ‡ 0åœ¨å·¦è¾¹ï¼Œä½†æˆ‘ä»¬åšäº†é•œåƒcanvasï¼Œæ‰€ä»¥é€»è¾‘åæ ‡ä¹Ÿè¦é•œåƒ
            const idxTip = { x: (1 - landmarks[8].x) * width, y: landmarks[8].y * height };
            const thumbTip = { x: (1 - landmarks[4].x) * width, y: landmarks[4].y * height };
            const middleTip = { x: (1 - landmarks[12].x) * width, y: landmarks[12].y * height };
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];

            // è®¡ç®—æ‰‹æŒ‡çŠ¶æ€ (ç®€å•ç‰ˆï¼šæŒ‡å°–æ˜¯å¦é«˜äºæŒ‡å…³èŠ‚)
            // 8: Index, 12: Middle, 16: Ring, 20: Pinky
            const isIndexUp = landmarks[8].y < landmarks[6].y;
            const isMiddleUp = landmarks[12].y < landmarks[10].y;
            const isRingUp = landmarks[16].y < landmarks[14].y;
            const isPinkyUp = landmarks[20].y < landmarks[18].y;

            // è·ç¦»è®¡ç®—
            const pinchDist = distance(idxTip, thumbTip);

            // --- çŠ¶æ€åˆ¤å®š ---

            // A. "V"å­—æ‰‹åŠ¿ (é£ŸæŒ‡+ä¸­æŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²) -> è§¦å‘æ¶ˆæ•£
            if (isIndexUp && isMiddleUp && !isRingUp && !isPinkyUp && distance(idxTip, middleTip) > 50) {
                explodeScreen();
                return; // ä¸æ‰§è¡Œå…¶ä»–æ“ä½œ
            }

            // B. æ•´ä¸ªæ‰‹æŒå¼ å¼€ (æ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´) -> åˆ‡æ¢èœå•
            if (isIndexUp && isMiddleUp && isRingUp && isPinkyUp) {
                const now = Date.now();
                if (now - lastMenuToggleTime > 1000) { // 1ç§’å†·å´
                    isMenuOpen = !isMenuOpen;
                    uiPanel.style.display = isMenuOpen ? 'grid' : 'none';
                    lastMenuToggleTime = now;
                    // é‡ç½®å†™å­—çŠ¶æ€
                    if (currentPath.length > 0) paths.push({ points: currentPath, color: brushColor, size: brushSize, tool: tool });
                    currentPath = [];
                }
                return;
            }

            // C. èœå•å¼€å¯æ—¶çš„äº¤äº’ (é£ŸæŒ‡æŒ‡ç‚¹)
            if (isMenuOpen) {
                if (isIndexUp && !isMiddleUp) {
                    updateCursor(idxTip);
                    checkUICollision(idxTip);
                } else {
                    cursor.style.display = 'none';
                }
                return; // èœå•å¼€å¯æ—¶ä¸å†™å­—
            } else {
                cursor.style.display = 'none';
            }

            // D. å†™å­— (Pinch: é£ŸæŒ‡æ‹‡æŒ‡æåˆ)
            // é˜ˆå€¼è®¾ä¸º 50px (è§†æ‘„åƒå¤´è·ç¦»è€Œå®šï¼Œå¯å¾®è°ƒ)
            if (pinchDist < 60) {
                // å¦‚æœæ˜¯æ©¡çš®æ“¦ï¼Œå…¶å®æ˜¯"ç©ºé—´ç§»é™¤"æ¨¡å¼
                if (tool === 'eraser') {
                    eraseAt(idxTip);
                } else {
                    // æ·»åŠ ç‚¹åˆ°å½“å‰è·¯å¾„ (è€ƒè™‘ç¼©æ”¾çš„é€†çŸ©é˜µï¼Œä»¥ä¾¿å­—ä¿æŒåœ¨ç»å¯¹ä½ç½®)
                    // ç®€å•çš„æ–¹æ¡ˆï¼šå­˜å‚¨ç›¸å¯¹äºå±å¹•çš„ç‚¹ï¼Œç»˜åˆ¶æ—¶åº”ç”¨ç¼©æ”¾
                    // ä¸ºç®€åŒ–ï¼Œæˆ‘ä»¬å­˜å‚¨åŸå§‹å±å¹•åæ ‡ï¼Œç»˜åˆ¶æ—¶åŸºäºä¸­å¿ƒç¼©æ”¾
                    currentPath.push({ x: idxTip.x, y: idxTip.y });
                }
            } else {
                // æ¾å¼€ï¼Œç»“æŸä¸€ç¬”
                if (currentPath.length > 0) {
                    paths.push({ points: currentPath, color: brushColor, size: brushSize, tool: tool });
                    currentPath = [];
                }
            }
        }

        // --- 5. åŒæ‰‹ç¼©æ”¾é€»è¾‘ ---
        function handleZoom(multiLandmarks) {
            // éœ€è¦ä¸¤åªæ‰‹éƒ½ä¼¸å‡ºé£ŸæŒ‡
            const h1 = multiLandmarks[0];
            const h2 = multiLandmarks[1];

            const h1Index = { x: (1 - h1[8].x) * width, y: h1[8].y * height };
            const h2Index = { x: (1 - h2[8].x) * width, y: h2[8].y * height };

            // ç®€å•æ£€æµ‹ï¼šæ˜¯å¦éƒ½åœ¨æŒ‡ç‚¹çŠ¶æ€(Index UP)
            const h1Point = h1[8].y < h1[6].y;
            const h2Point = h2[8].y < h2[6].y;

            if (h1Point && h2Point) {
                const dist = distance(h1Index, h2Index);

                if (lastPinchDist !== null) {
                    const delta = dist - lastPinchDist;
                    // çµæ•åº¦è°ƒæ•´
                    zoomLevel += delta * 0.005;
                    if (zoomLevel < 0.1) zoomLevel = 0.1;
                    if (zoomLevel > 5) zoomLevel = 5;
                }
                lastPinchDist = dist;
            } else {
                lastPinchDist = null;
            }
        }

        // --- 6. ç»˜å›¾ä¸æ¸²æŸ“ ---
        function drawPaths() {
            canvasCtx.save();

            // åº”ç”¨ç¼©æ”¾å˜æ¢
            // ä»¥å±å¹•ä¸­å¿ƒä¸ºåŸºå‡†ç¼©æ”¾
            canvasCtx.translate(width / 2, height / 2);
            canvasCtx.scale(zoomLevel, zoomLevel);
            canvasCtx.translate(-width / 2, -height / 2);

            // ç»˜åˆ¶å·²å®Œæˆçš„è·¯å¾„
            for (const pathObj of paths) {
                drawSinglePath(pathObj.points, pathObj.color, pathObj.size, pathObj.tool);
            }
            // ç»˜åˆ¶å½“å‰æ­£åœ¨å†™çš„è·¯å¾„
            if (currentPath.length > 0) {
                drawSinglePath(currentPath, brushColor, brushSize, tool);
            }

            canvasCtx.restore();
        }

        function drawSinglePath(points, color, size, type) {
            if (points.length < 2) return;

            canvasCtx.beginPath();
            canvasCtx.lineWidth = size;
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';

            if (type === 'eraser') {
                // åœ¨å•å±‚Canvasä¸­ï¼Œæ©¡çš®æ“¦æœ€å¥½çš„æ•ˆæœæ˜¯ "dest-out"ï¼Œä½†è¿™ä¼šæ“¦é™¤è§†é¢‘èƒŒæ™¯
                // è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šå¦‚æœå·¥å…·æ˜¯eraserï¼Œå…¶å®æˆ‘ä»¬åœ¨handleGesturesé‡Œå¤„ç†äº†eraseAtæ•°æ®åˆ é™¤
                // æ‰€ä»¥è¿™é‡Œä¸éœ€è¦ç”»æ©¡çš®æ“¦è½¨è¿¹ï¼Œæˆ–è€…ç”»ä¸€ä¸ªæŒ‡ç¤ºæ€§çš„åœˆ
                return;
            } else {
                canvasCtx.strokeStyle = color;
                canvasCtx.globalCompositeOperation = 'source-over';
            }

            canvasCtx.moveTo(points[0].x, points[0].y);
            // äºŒæ¬¡è´å¡å°”æ›²çº¿å¹³æ»‘
            for (let i = 1; i < points.length - 2; i++) {
                const xc = (points[i].x + points[i + 1].x) / 2;
                const yc = (points[i].y + points[i + 1].y) / 2;
                canvasCtx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            // å¤„ç†æœ€åä¸¤ç‚¹
            if (points.length > 2) {
                canvasCtx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
            }
            canvasCtx.stroke();
        }

        // æ©¡çš®æ“¦é€»è¾‘ï¼ˆæ•°æ®å±‚åˆ é™¤ï¼‰
        function eraseAt(pos) {
            const radius = 30 / zoomLevel; // æ©¡çš®æ“¦å¤§å°éšç¼©æ”¾å˜åŒ–
            // éå†æ‰€æœ‰è·¯å¾„ï¼Œç§»é™¤åœ¨èŒƒå›´å†…çš„ç‚¹
            // è¿™åœ¨JSä¸­æ¯”è¾ƒè€—è´¹æ€§èƒ½ï¼Œè¿™é‡Œåšç®€åŒ–ï¼šå¦‚æœè·¯å¾„æœ‰ä»»æ„ç‚¹åœ¨èŒƒå›´å†…ï¼Œåˆ‡æ–­è·¯å¾„
            // ä¸ºæ€§èƒ½è€ƒè™‘ï¼Œæˆ‘ä»¬åªæ£€æŸ¥ç‚¹

            // æ›´å¥½çš„æ–¹å¼ï¼šä¸åšç‰©ç†åˆ é™¤ï¼Œåªç”»ä¸€æ¡ globalCompositeOperation = 'destination-out' çš„çº¿ï¼Ÿ
            // ä¸è¡Œï¼Œå› ä¸ºæˆ‘ä»¬èƒŒæ™¯æ˜¯è§†é¢‘ï¼Œdest-outä¼šæŠŠè§†é¢‘æŒ–ç©ºã€‚
            // å¿…é¡»æ“ä½œ path æ•°æ®ã€‚

            for (let i = paths.length - 1; i >= 0; i--) {
                let pObj = paths[i];
                // ç®€å•è¿‡æ»¤ï¼šå¦‚æœè¿™ä¸ªç¬”ç”»ç¦»æ‰‹æŒ‡å¤ªè¿œï¼Œè·³è¿‡
                // ç»†ç²’åº¦ï¼šè¿‡æ»¤ç‚¹
                pObj.points = pObj.points.filter(p => distance(p, pos) > radius);
                // å¦‚æœç‚¹è¢«åˆ å®Œäº†ï¼Œç§»é™¤ç¬”ç”»
                if (pObj.points.length < 2) {
                    paths.splice(i, 1);
                }
            }
        }

        // --- 7. ç‰¹æ•ˆä¸UI ---

        function updateCursor(pos) {
            cursor.style.display = 'block';
            cursor.style.left = pos.x + 'px';
            cursor.style.top = pos.y + 'px';
        }

        function checkUICollision(pos) {
            const items = document.querySelectorAll('.ui-item');
            const panelRect = uiPanel.getBoundingClientRect();

            // è½¬æ¢ pos åˆ°è§†å£åæ ‡ (fixed/absolute)
            // pos æ˜¯ç›¸å¯¹äº canvas çš„ï¼Œcanvas æ˜¯å…¨å±ï¼Œæ‰€ä»¥ pos.x, pos.y å°±æ˜¯ clientX, clientY

            let hovered = null;

            items.forEach(item => {
                const rect = item.getBoundingClientRect();
                if (pos.x >= rect.left && pos.x <= rect.right &&
                    pos.y >= rect.top && pos.y <= rect.bottom) {
                    hovered = item;
                    item.classList.add('hovered');
                } else {
                    item.classList.remove('hovered');
                }
            });

            if (hovered) {
                if (lastHoveredItem !== hovered) {
                    lastHoveredItem = hovered;
                    // å¼€å§‹è®¡æ—¶
                    clearTimeout(hoverTimer);
                    hoverTimer = setTimeout(() => selectItem(hovered), 600); // æ‚¬åœ600msé€‰ä¸­
                }
            } else {
                lastHoveredItem = null;
                clearTimeout(hoverTimer);
            }
        }

        function selectItem(item) {
            const type = item.dataset.type;
            const val = item.dataset.val;

            // è§†è§‰åé¦ˆ
            item.classList.add('active');
            setTimeout(() => item.classList.remove('active'), 200);

            // é€»è¾‘åº”ç”¨
            if (type === 'color') {
                brushColor = val;
                tool = 'pen'; // é€‰é¢œè‰²è‡ªåŠ¨åˆ‡å›ç¬”
            } else if (type === 'size') {
                brushSize = parseInt(val);
            } else if (type === 'tool') {
                tool = val;
            }

            // æ›´æ–°UIçŠ¶æ€
            updateUIState();
        }

        function updateUIState() {
            // ç®€å•çš„UIåˆ·æ–°ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥ç”¨Vue/React
            document.querySelectorAll('.ui-item').forEach(el => {
                el.style.borderColor = '#444';
                if (el.dataset.val === brushColor && el.dataset.type === 'color') el.style.borderColor = '#00ff00';
                if (el.dataset.val == brushSize && el.dataset.type === 'size') el.style.borderColor = '#00ff00';
                if (el.dataset.val === tool && el.dataset.type === 'tool') el.style.borderColor = '#00ff00';
            });
        }

        function explodeScreen() {
            if (paths.length === 0) return;

            // å°†æ‰€æœ‰è·¯å¾„çš„ç‚¹è½¬æ¢ä¸ºç²’å­
            paths.forEach(path => {
                path.points.forEach(p => {
                    // é™é‡‡æ ·ï¼Œæ¯å‡ ä¸ªç‚¹ç”Ÿæˆä¸€ä¸ªç²’å­ï¼Œé˜²æ­¢å¤ªå¡
                    if (Math.random() > 0.5) {
                        // éœ€è¦åº”ç”¨å½“å‰çš„ zoom å˜æ¢å¾—åˆ°å®é™…å±å¹•ä½ç½®ï¼Œæˆ–è€…ç²’å­ä¹Ÿåœ¨ zoom ç³»ç»Ÿä¸­
                        // è¿™é‡Œä¸ºäº†ç®€å•ï¼Œç²’å­äº§ç”Ÿåå°±ä¸å— zoom å½±å“ï¼Œç›´æ¥é£˜è½
                        // è¿™æ ·æ›´åƒ "å¢¨æ°´ä»çº¸ä¸ŠæŠ–è½" çš„æ„Ÿè§‰

                        // è®¡ç®—å˜æ¢åçš„åæ ‡
                        const centeredX = p.x - width / 2;
                        const centeredY = p.y - height / 2;
                        const screenX = centeredX * zoomLevel + width / 2;
                        const screenY = centeredY * zoomLevel + height / 2;

                        particles.push(new Particle(screenX, screenY, path.color));
                    }
                });
            });

            paths = []; // æ¸…ç©ºè·¯å¾„
            currentPath = [];
        }

        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.draw(canvasCtx);
                if (p.alpha <= 0 || p.y > height) {
                    particles.splice(i, 1);
                }
            }
        }

        // --- 8. MediaPipe åˆå§‹åŒ– ---
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });

        camera.start();

        // åˆå§‹åŒ–é€‰ä¸­çŠ¶æ€
        updateUIState();

    </script>
</body>

</html>